---
title: "Adding OOP to the Egg Parser"
key: egg-oop-parser
published: true
date: 2022/04/12
delivery: "2022/05/05"
order: 13
layout: Practica
sidebar: auto
template: "https://github.com/ULL-ESIT-PL-2122/egg-oop-parser-template"
rubrica: 
  - Added properties with brackets
  - Added dot selector for objects 
  - Added Array literal notation 
  - Added Object literal notation
  - The lexer generator module has being extended to support lexical transformations
  - Added token transformation <code>replace/WORD COLON/STRING COMMA/</code>
  - Correctly solves dot lexical ambiguity for numbers and properties
  - Lexical transformation <code>replace/DOT NUMBER{4.3}/DOT NUMBER{4} DOT NUMBER{3}/</code>
  - Multiple Object indexation supported 
  - Currying works with methods <code>4&#91;\"+\", 5&#93;(3)</code>
  - The dot can be used to select indexed properties <code>[[0],1].0.0</code>
  - Contiene suficientes tests
  - Se provee un workflow sencillo para convertir r√°pidamente un ejemplo operativo en un test 
  - Estudio de covering
  - Se ha hecho CI con GitHub Actions
  - M√≥dulo bien documentado 
  - Informe hecho con Vuepress desplegado
  - Se ha publicado como m√≥dulo y se ha hecho un buen uso del versionado sem√°ntico en la evoluci√≥n del m√≥dulo
---

# {{$frontmatter.title }}

<!-- Only the + implemented as method of numbers. Need to implemetn the rest ... -->

## Introduction

In this lab, we want to increase the expressiveness of our language.

The following example shows some of the extensions that we want to introduce:

```ruby
cat examples/object-colon-selector.egg 
do (
  def(x, { # object literals!
    c: [1, 2, 3], # array literals!
    gc:  fun(
           element(self, "c") # old way works
         ), 
    sc:  fun(value, # look at the left side of the assignment!
           =(self.c[0], value)
         ),
    inc: fun( 
           =(self.c[0], +(self.c[0], 1)) 
         ) 
  }),
  print(x),
  print(x.gc()),    # [1, 2, 3]
  x.sc(4),
  print(x.gc()),    # [4,2,3]
  x.inc(),
  print(x.gc()),    # [5,2,3]
  print(x.c.pop()), # 3
  print(x.c)        # [5,2]
)
```

Take a look at some of the features introduced:

* Added braces `{}` to refer to object literals: `def(x, { ... })`
* Note the appearance of the *colon* `:` token to separate the attribute name from the value in an object
* Added brackets `[]` to refer to *array literals* `[1, 2, 3]`
* It is possible to access the properties of an object using the dot as in `x.c`
* In this version of the Egg language, `self` denotes the object. it is like `this` in JS
* It is possible to access the properties of any object using square brackets as in `self.c[0]`

## Download evm with OOP extensions 

During the development of this lab, you can execute the ASTs generated by your parser using one of the interpreters in this release:

* [Egg Virtual Machine with OOP extensions for Windows/Linux/Mac OS](https://github.com/ULL-ESIT-PL-2122/egg-oop-parser-template/releases/tag/1.0.0)

download the version you need for the development of this lab, make a symbolic link to have it at hand:

```
‚úó ln -s ~/campus-virtual/shared/egg/oop-evm-releases/evm-2122-macos ./evm
``` 

and try with some example:

```js
‚úó ./evm examples/object-colon-selector.json 
{"c":[1,2,3]}
[1,2,3]
[4,2,3]
[5,2,3]
3
[5,2]
```

## Multiple Attribute Indexation

You can make multiple indexation of an object so that 
`a[0,2]` means `a[0][2]`:

```js
‚úó cat examples/multiple-properties.egg 
do(
    def(a, [[4,5,6], 1,2,3]),
    def(b, a[0,2]),
    print(b) # 6
)%                                                                                                                   
‚úó bin/eggc.js examples/multiple-properties.egg
‚úó npx evm examples/multiple-properties.json   
6
```

Same for objects `a["p", "q", "r"]` means `a.p.q.r` or `a["p"]["q"]["r"]`:

```js
‚úó cat examples/multiple-properties-object-dot.egg        
do(
    def(a, { p : { q : { r : 1 } } }),
    def(b, a["p", "q", "r"]),
    print(b),      # 1
    print(a.p.q.r) # Same
)     
‚úó bin/eggc.js examples/multiple-properties-object-dot.egg
‚úó npx evm examples/multiple-properties-object-dot.json   
1
1
```

This is the section of the grammar that allows the use of property indexation:

```js
expression -> ...
    | %WORD applies

applies -> calls
    | properties
    | null
properties ->  bracketExp  applies

bracketExp -> "["  commaExp "]"

commaExp -> null
   | expression ("," expression):*
```

## Property indexation and commaExp is nullable

Notice that `commaExp` is nullable, and thus it fits with an empty indexation expression like `a[]` which makes nonsense. To fix the problem, we can change the grammar or, alternatively, force the presence of at least one index inside the semantic expression associate to `bracketExp`:

```js
bracketExp -> "["  commaExp "]"  {% ([lb, commaExp, rb]) => checkNonEmpty(lb, commaExp) %}
```

so that we can protest if the index list is empty:

```ruby
‚ûú  egg-oop-parser-solution git:(master) cat examples/empty-bracket.egg 
do(
    def(a, [1,2,3]),
    print(a[])
)
```

```
‚ûú  egg-oop-parser-solution git:(master) bin/eggc.js examples/empty-bracket.egg
There was an error: Syntax error accesing property at line 3 col 12.
Specify at least one property.
```

## The *Syntactically Correct, Semantically Absurd* Language Design Pattern

::: tip The "Syntactically Correct, Semantically Absurd" Language Design Pattern

Whenever a phrase is syntactically correct and it seems semantically absurd like is the case of `x[]`, 
I usually stop for a moment and consider ü§î if there is some not obvious meaning we can give to it.

[![Colorless green ideas sleep furiously](/images/colorless-green-ideas-sleep-furiously.png)](https://en.wikipedia.org/wiki/Colorless_green_ideas_sleep_furiously)  Noam Chomsky. 1957 *Syntactic Structures*


For instance all arrays, objects and maps have in common the `length` property. 
2
* May be we can give to `x[]`the meaning "to return a deep copy of `x`"? :+1:
* May be we can give to `x[]`the meaning "to return `x.length`"? :-1:
:::

See also [Syntactically correct, semantically incorrect sentence](https://english.stackexchange.com/questions/29504/syntactically-correct-semantically-incorrect-sentence?newreg=67fbf1282e674c20bef3ff65f864a7a9)

## Currying in Egg

!!!include(includes/currying.md)!!!

## Selectors: the Dot Operator

Most OOP languages allow the use of the notation `x.y` as a synonym of `x["y"]`. 
To add it to Egg we add the production `properties -> selector applies` to the grammar.

Lines 8-10 show the rules for the new syntactic variable `selector`:

```js{6,8-10}
applies -> calls
    | properties
    | null

properties ->  bracketExp  applies
    | selector applies            

selector   ->  
     "." %WORD
   | "." %NUMBER
```

We want to allow programs  like the following:

```ruby
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/dot-chain.egg 
print([1,4,5].join("-").length) # Same as array(1,4,5)["join"]("-")["length"]                          
‚ûú  egg-oop-parser-solution git:(master) ‚úó bin/egg examples/dot-chain
5
```

same thing with object literals:

```ruby
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/dot-obj-literal.egg 
print({x : 3}.x) # 3
‚ûú  egg-oop-parser-solution git:(master) ‚úó bin/egg examples/dot-obj-literal
3
```

and also:

```js
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/dot-num.egg 
print(c)
‚ûú  egg-oop-parser-solution git:(master) ‚úó bin/egg examples/dot-num 
4.30
```

and even program like this one:

```js
‚ûú  egg-oop-parser-solution git:(master) ‚úó cat examples/array-dot.egg 
do(
    def(a, [[1,2],3]),
    print(a.0.1)
)

‚ûú  egg-oop-parser-solution git:(master) ‚úó bin/egg examples/array-dot 
2
```

Think on the sub-expression above `a.0.1` from the lexical analysis point of view. A naif approach will lead to the  token's flow `[WORD{a}, DOT, NUMBER{0.1}]` 

## Extending the ASTs

Consider the following Egg program:

```ruby
‚úó cat examples/dot-num.egg                         
print(4.3.toFixed(2))
```

The AST generated has a new type of node called `property` to represent object property access:

```js{9-11}
‚úó cat examples/dot-num.json 
{
  "type": "apply",
  "operator": { "type": "word", "name": "print" },
  "args": [
    {
      "type": "apply",
      "operator": {
        "type": "property",
        "operator": { "type": "value", "value": 4.3, },
        "args": [ { "type": "value", "value": "toFixed", }  ]
      },
      "args": [ { "type": "value", "value": 2, } ]
    }
  ]
}
```

1. The `type`  in line 9 is `property`, which tell us that this AST node correspond to the operation of accesing the attributes of the object in its `operator` child.
2. The `operator` in line 10 refers to the AST of the Egg object being described $obj$ (`4.3`).  
3. The `args` in line 11 refers to the ASTs of the properties. 
     - The first element of `args` $t_0$ is the AST of a direct property $p_0$ of the object $obj$ in the operand (`toFixed`).  
     - The second $t_1$ is a property $p_1$ of the object $p_0$
     - The third $t_2$ is a property $p_2$ of the object $p_1$
     - ... and so on


Our parser should therefore produce an AST conforming to this tree grammar:

```ruby
ast: VALUE
   | WORD 
   | APPLY( operator:WORD args:[ ast * ]))
   | PROPERTY(operator:WORD args:[ ast * ]))
```

* Los nodos `APPLY` tienen dos atributos `operator` y `args`
* El atributo `operator`de un nodo `APPLY` contiene informaci√≥n sobre la funci√≥n que lo interpreta (`if`, `while`, `print`, `+`, etc.)
* El atributo `args` de un nodo `APPLY` es un `ARRAY` conteniendo los ASTs que  se corresponden con los argumentos para la funci√≥n asociada con `operator`. 

* Los nodos `PROPERTY` tienen dos atributos `operator` y `args`
* El atributo `operator` de un nodo `PROPERTY` contiene informaci√≥n sobre el objeto (por ejemplo en `[1,2,3][0]` el operator ser√≠a el AST de `[1, 2, 3]`, En `{a: 1, b:2}.a` ser√≠a el AST de `{a: 1, b:2}`)
* El atributo `args` de un nodo `PROPERTY` es un `ARRAY` conteniendo los ASTs que  se corresponden con los atributos/propiedades del `objeto` que est√° en `operator` (Para la expresi√≥n `[[1,2],3][0,1]`  ser√≠an los ASTs de `[0, 1]` o  para 
`[[1,2],3]["length"]`  ser√≠a el AST de `["length"]`; para `{a: [1, 2], b:2}["a", 0]`  ser√≠an los ASTs de `["a", 0]`). 

* Los nodos `WORD` son nodos hoja y tienen al menos el atributo `name`. 
* Los nodos `VALUE` tienen al menos el atributo `value`.

Por ejemplo, el AST para `4.3.toFixed(2)` se podr√≠a describir mediante este t√©rmino: 

```ruby
APPLY(
  operator:PROPERTY(
    operator:VALUE{value:4.3}, 
    args:VALUE{value:"toFixed"}
  ),
  args:VALUE{value:2}
)
``` 

A la derecha del tipo de nodo y entre llaves escribimos las parejas` atributo: valor` que nos interesa resaltar. 

Si tiene dificultades repase la secci√≥n [Anatom√≠a de los AST para Egg](/temas/syntax-analysis/ast.html#anatomia-de-los-ast-para-egg) 

## The Dot Ambiguity: Property dot or Mantissa dot?

Al introducir el *dot* para seleccionar la propiedad del objeto se produce una ambiguedad con el punto en los flotantes:

```js
‚úó cat test/examples/dot-num.egg 
print(4.3.toFixed(2))
```
::: tip Propuesta
Se propone que la ambiguedad se resuelva dando prioridad a la interpretaci√≥n como *punto de n√∫mero* si el punto va seguido de un d√≠gito, en otro caso estamos accediendo a la propiedad del n√∫mero
:::

Ejemplo:

```
bin/eggc.js test/examples/dot-num.egg 
‚úó npx evm test/examples/dot-num.json  
4.30
```
::: tip Solution
So, inside the lexical analyzer, we have to force that for a *dot* to be interpreted as *numeric* the **dot** has to be followed by a digit:

```js{1}
const NUMBER = /(?<NUMBER>[-+]?\d+(\.\d+)?(?:[eE][-+]?\d+)?)/; // \d+ to resolve ambiguity
const tokens = [ SPACE, NUMBER, ...  DOT,  ... ];
```
::: 

Esto es diferente de lo que hace JS que no permite usar el punto como selector de atributo:

```js
‚ûú  pl2122apuntes git:(main) node
Welcome to Node.js v16.0.0.
Type ".help" for more information.
> 4.toFixed(2)
4.toFixed(2)
^^
Uncaught SyntaxError: Invalid or unexpected token
```

En JS la ambiguedad se resuelve parentizando el n√∫mero:

```js
> 4.toFixed(2)
4.toFixed(2)
^^
Uncaught SyntaxError: Invalid or unexpected token
> (4).toFixed(2)
'4.00'
```

##  Lexical Transformations 

To facilitate the task of doing this lab, it is convenient that we return to the [lexer-generator](/practicas/lexer-generator) module and modify its API a bit, providing it with the ability to add lexical transformations.

To do this, the `nearleyLexer` function will now receive an additional parameter of an object with options:

```js
let lexer = nearleyLexer(tokens, { transform: transformerFun});
```

The only option we are going to add is `transform`. When specified, it applies the `transformerFun` function to each of the `tokens` of the lexer object generated by `nearleyLexer`. 

We can have more than one lexical transformations to apply. Thus, we allow the `transform` property to be an array, so that the builder `nearleyLexer` can be called this way:

```js
let lexer = nearleyLexer(tokens, { transform: [colonTransformer, NumberToDotsTransformer] });
```

::: tip Solution
To achieve the goal we have to modify the `reset` method of our nearley compatible object:

```js{6-13}
reset: function(data, info) { 
  this.buffer = data || '';
  this.currentPos = 0;
  let line = info ? info.line : 1;
  this.tokens = lexer(data, line);
  if (options && options.transform) {
    if (typeof options.transform === 'function') {
      debugger;
      this.tokens = options.transform(this.tokens);
    } else if (Array.isArray(options.transform)) {
      options.transform.forEach(trans => this.tokens = trans(this.tokens))
    }
  } 
  return this;
}
```
:::

## The Lexical Word Colon Transformation

We want to add the colon as syntactic sugar to our language. 
We want to transform all the pair subsequences `WORD, COLON`  into `STRING, COMMA` sequences so that phrases like `x: 4` are interpreted as `"x", 4"`. 

In this way we can write a program like this:

```ruby
‚úó cat examples/colon.egg 
do(
  def(b, [a:4]), # The : is a "lexical" operator
  print(b)
)                                                                                                           
```

so that when compiled and executed produces:

```
‚úó bin/eggc.js examples/colon.egg
‚úó npx evm examples/colon.json   
["a",4]
```
::: tip Proposal
The idea is that inside our lexer we write a lexical transformation function:

```js
function colonTransformer(tokens) {
  // ... s/WORD COLON/STRING COMMA/g
 return tokens;
}
```
:::

This transformation is what allow us the elegant syntax to describe the object in the example `examples/object-colon-selector.egg` in section [introduction](#introduction) 


```ruby
def(x, { 
  c: [1, 2, 3], 
  gc:  fun(element(self, "c")), 
  sc:  fun(value, =(self.c[0], value)),
  inc: fun(=(self.c[0], +(self.c[0], 1)))
})
```

## Full Grammar 

The following grammar is a NearleyJS non ambiguous grammar that allows the requested features and extends the previous Egg grammar we introduced in lab [egg-parser](/practicas/egg-parser.html):

```js
program -> expression %EOF
expression -> 
      %STRING  optProperties
    | %NUMBER  optProperties
    | bracketExp optProperties 
    | curlyExp   optProperties
    | %WORD applies           

applies -> calls
    | properties
    | null
calls ->  parenExp applies
properties ->  bracketExp  applies
    | selector applies            

parenExp   -> "("  commaExp ")"
bracketExp -> "["  commaExp "]"
curlyExp   -> "{"  commaExp "}"

selector   ->  
     "." %WORD
   | "." %NUMBER
commaExp -> null
   | expression ("," expression):*

optProperties -> null
   | properties
```

See also the [Syntax Diagram/Railroad Diagram](/temas/interpretation/egg-oop-syntax-diagram)

## A new Ambiguity: Number Dot Number

**Just for fun and to go beyond what any other programming language allows** we want the dot to work
with numbers as property selector. This is something, to my knowledge, no language allows. For instance, in JS:

```js{8-11}
‚ûú  src git:(main) ‚úó node
Welcome to Node.js v16.0.0.
Type ".help" for more information.
> a = [[1,2],3,4]
[ [ 1, 2 ], 3, 4 ]
> a[0][0]
1
> a.0.0
a.0.0
 ^^
Uncaught SyntaxError: Unexpected number
```

You can not use the notation `a.0.0` to select the `a[0][0]` element since allowing this notation
confuses the interpreter. 

Even if the JS designers would take a decision as the one we took in section  [The Dot Ambiguity: Property dot or Mantissa dot?](#the-dot-ambiguity-property-dot-or-mantissa-dot) it will not suffice: The lexer will interpret the `0.0` in `a.0.0` as a word `a` followed by floating point `0.0`!.

This goal (the dot to work with numbers as property selector) is the reason I introduced  the `"." %NUMBER` production in the `selector` rule:

```js{3}
selector   ->  
     "." %WORD
   | "." %NUMBER
```

this, if correctly implemented, will  allow us to write programs like this one:

```js{3}
‚úó cat examples/array-dot.egg 
do(
    def(a, [[1,2],3]),
    print(a.0.1)
)
```

that will produce this output:

```{3}
‚úó bin/eggc.js examples/array-dot.egg
‚úó npx evm examples/array-dot.json
2
``` 

the key observation here is that 

::: tip Disambiguation Rule
**In an Egg program a number token corresponding to a floating point as `0.1` or `0.0` can not be preceded by a dot token**. 
::: 

Notice that before a dot token not necessarily comes a word, but it can be a complex expression like in this other example (Observe the first dot at line 4):

```ruby{4}
‚úó cat examples/function-returning-array-dot-number.egg 
do(
    def(f, fun([[0,Math.PI],2])), # A function that returns an array
    print(f().0.1)
)
``` 

When executed we obtain:

```{3}
‚úó bin/eggc.js examples/function-returning-array-dot-number.egg
‚úó npx evm examples/function-returning-array-dot-number.json   
3.141592653589793
```

::: tip Proposal
The proposed solution is to write another lexical transformation:

```js{1}
// Substitute DOT NUMBER{4.3} by DOT NUMBER{4} DOT NUMBER{3}
function NumberToDotsTransformer(tokens) {
    /* ... fill the code ... */
    return tokens;
}
```
:::

## Array Literals 

Let us study now the support for Array Literals. The involved rules are:

```js{2,3}
expression ->  ...
    | bracketExp optProperties
bracketExp -> "["  commaExp "]"

optProperties -> null
   | properties
```

::: tip 
The idea is that the transformer associated to the `bracketExp` rule builds  an apply node like 

```ruby
APPLY(operator:(WORD{name:array}, args: commaexp)
```

where `commaexp` is the AST forest associated with the appearance  of `commaExp` in the production `bracketExp -> "["  commaExp "]"`.
:::

## Object Literals 

The production rules for object literals are:

```js
expression -> ...
    | curlyExp   optProperties
curlyExp   -> "{"  commaExp "}"

optProperties -> null
   | properties
```

::: tip
As for array literals, the idea is that the transformer associated to the `curlyExp` rule builds  an apply node like 

```ruby
APPLY(operator:(WORD{name:object}, args: commaexp)
```
:::

## The *Begin End Something* Language Design Pattern

The solution we have used to solve the two previous sections [Array Literals](#array-literals) and [Object Literals](#object-literals) follows a pattern I will call the **Begin-End-Something Pattern**:

::: tip The "Begin End Something" Language Design Pattern
1. Add a couple of tokens to the language to signal the beginning and the end of the **new specialized category of expressions**:  for instance add `[` to begin array literals and `]` to end array literals
   * Introduce the new tokens in the lexer (be carefull with conflicts, specially with "expansive" tokens. Don't trample on existing "reserved words")
   * Modify the grammar adding the new rule(s) for the new kind of expression
2. Build an AST for the the new category by adding a function `buildCategory` to your `build-ast.js` library.
   * The function `buildCategory` returns in fact a specialized case of an already existent kind of AST
   * Remember to export the new function and import the new function in your grammar file
::: 

Following these instructions it is trivial to extend Egg with a family of constructs as 

* `(` ... `)` as a synonym of `do( ...)`: See an example in the branch `doendo` of the solution repo

  ```ruby
  ‚ûú  egg-oop-parser-solution git:(doendo) ‚úó cat examples/do-endo.egg 
  (
    def(a,4),
    print(a)
  )
  ‚ûú  egg-oop-parser-solution git:(doendo) ‚úó bin/egg examples/do-endo
  4
  ```
* `loop` ... `end loop` or `While` ... `end While` as a synonym of `while(...)`. Do not use `while` ... `end while` for the delimiter tokens or you will trample with the already existing word `while`
*  etc.

## Error Management

The errors produced by Nearley.JS are quite verbose:

```ruby
‚ûú  egg-oop-parser-solution git:(b2bc2de) cat test/errors/unexpected-token-comma.egg
+{2,3}
```
```                                   
‚ûú  egg-oop-parser-solution git:(b2bc2de) bin/eggc.js test/errors/unexpected-token-comma.egg
There was an error: Error near "{" in line 1
Unexpected LCB token: "{". Instead, I was expecting to see one of the following:

A "(" based on:
    parenExp ‚Üí  ‚óè "(" commaExp ")"
    calls ‚Üí  ‚óè parenExp applies
    applies ‚Üí  ‚óè calls
    expression ‚Üí %WORD ‚óè applies
    program ‚Üí  ‚óè expression %EOF
A "[" based on:
    bracketExp ‚Üí  ‚óè "[" commaExp "]"
    properties ‚Üí  ‚óè bracketExp applies
    applies ‚Üí  ‚óè properties
    expression ‚Üí %WORD ‚óè applies
    program ‚Üí  ‚óè expression %EOF
A "." based on:
    selector ‚Üí  ‚óè "." %WORD
    properties ‚Üí  ‚óè selector applies
    applies ‚Üí  ‚óè properties
    expression ‚Üí %WORD ‚óè applies
    program ‚Üí  ‚óè expression %EOF
A "." based on:
    selector ‚Üí  ‚óè "." %NUMBER
    properties ‚Üí  ‚óè selector applies
    applies ‚Üí  ‚óè properties
    expression ‚Üí %WORD ‚óè applies
    program ‚Üí  ‚óè expression %EOF
A EOF token based on:
    program ‚Üí expression ‚óè %EOF
```

In version `2.20.1` of Nearley, the Error object has an attribute `token` than can be used to simplify the error  message.

In the example below we make use of a RegExp to traverse the `message` attribute of the error and add to the message the expected tokens:

```js
function parseFromFile(origin) {
  try {
    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
    const source = fs.readFileSync(origin, 'utf8');
    parser.feed(source);
    const ast = parser.results[0];
    return ast;
  }
  catch(e) {
    let token = e.token;
    let message = e.message;
    let expected = message.match(/(?<=A )".*"(?= based on:)/g);
    let newMessage = `Unexpected ${token.type} token "${token.value}" `+
    `at line ${token.line} col ${token.col}\nTokens expected: ${expected}`;  
    throw new Error(newMessage)
  }
}
```

When executed with an erroneous input the message is simplified to:

```
‚úó bin/eggc.js test/errors/unexpected-token-comma.egg
Unexpected LCB token "{" at line 1 col 2
Tokens expected: "(","[",".","."
```

Another related idea with error management is to introduce production rules for specific error situations. For instance, the rule at line 8 `expression -> %EOF` is added to control when in the middle of the parsing an unexpected end of file occurs:

```js{8}
expression -> 
      %STRING  optProperties   {% buildStringValue %}
    | %NUMBER  optProperties   {% buildNumberValue %}
    | bracketExp optProperties {% buildArray %}
    | curlyExp   optProperties {% buildObject %}
    | "(" commaExp ")"         {% buildDo %}
    | %WORD applies            {% buildWordApplies %}
    | %EOF                     {% dealWithError %}
```


## Resources

* [GitHub Actions. The Secrets context](/temas/introduccion-a-javascript/github-actions.html#the-secrets-context)
* [Installing Private Packages in a GitHub Action](/temas/introduccion-a-javascript/creating-and-publishing-npm-module.html#installing-private-packages-in-a-github-action)
* [latest-version-cli](https://github.com/sindresorhus/latest-version-cli) Get the latest version of an npm package
* [Egg Virtual Machine with OOP extensions for Windows/Linux/Mac OS](https://github.com/crguezl/oop-evm-releases/releases/tag/v1.0.0)
* [Eloquent JS: Chapter 11. Project: A Programming Language](http://eloquentjavascript.net/11_language.html)
* [V√≠deo *Programando un bucle REPL para el lenguaje Egg*](https://youtu.be/5gIlt6r29lw)
* El m√≥dulo [@ull-esit-pl/example2test](https://www.npmjs.com/package/@ull-esit-pl/example2test)


